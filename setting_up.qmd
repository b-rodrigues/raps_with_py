# Setting up a development environment

I have to start with on of the hardest chapters of the book, how to set up a
development environment for Python.

If you are already using Python, you already have an environment set up and
might be familiar with `pyenv` or other similar tools. I would still suggest you
read this chapter and see if you agree with how I approach this issue. You may
want to adapt your current workflow to it, or keep on doing what you’ve been
doing up until now, it is up to. If you’re completely new to Python, then you
definitely need to read this chapter, but also, I need to remind you that this
is not a book about Python per se. So I won’t be teaching you any Python (I
wouldn’t really be competent to do so either) and you might want to complement
reading this book with another that focuses on actually teaching Python.
Remember, this book is about building reproducible analytical pipelines!

## Why is installing Python such a hard problem?

If you google "how to install Python" you will find a surprising amount of
articles explaining how to do it. I say "surprising amount" because one might
expect to install Python like any other piece of software. If you’re already
familiar with R, you could think that installing Python would be done the same
way: download the installer for your operating system, and then install it. And,
actually, you can do just that for Python as well. So why are there 100s of
articles online explaining how to install Python, and why aren’t all of these
articles simply telling you to download the installer to install Python? Why
did I write this chapter on installing Python?

Well, there are several thing that we need to deal with if we want to install
and use Python the "right way". First of all, Python is pre-installed on Linux
distributions and older versions of macOS. So if you’re using one of these
operating systems, you could use the built-in Python interpreter, but this is
not recommended. The reason being that these bundled versions are generally
older, and that you don’t control their upgrade process, as these get updated
alongside the operating system. On Windows and newer versions of macOS, Python
is, as far as I know, never bundled, so you’d need to install it anyways.

Another thing that you need to consider is that newer Python versions can
introduce breaking changes, making code written for an earlier version of Python
not run on a newer version of Python. This is not a Python-specific issue: it
happens with any programming language. So this means that ideally you would want
to bundle a Python version with your project’s code.

The same holds true for individual packages: newer versions of packages might
not even work with older releases of Python, so to avoid any issues, an analysis
would get bundled with a Python release and Python packages. This bundle is what
I call a development environment, and in order to build such development environment,
specific tools have to be used. And there’s a lot of these tools in the Python
ecosystem... so much so that when you’re first starting, you might get lost.
So here is he two tools that I use for this, and that I think work quite well: `micromamba`
and `pipenv`.

The workflow is as follows:

- Install `micromamba`, a lightweight package manager
- Using `micromamba`, create an environment that contains a Python interpreter and `pipenv`
- Using this environment, install the required packages using `pipenv`
- `pipenv` will automatically generate two very useful files, `Pipfile` and `Pipfile.lock`

In the following sections I detail this process.

## Creating a project-specific development environment

What we want is to have project-specific development environments that should include a
specific Python version, specific versions of Python packages and all the code to actually
run the project.

I’m going to assume that you don’t have any Python version available on your computer
and need to get one. Let’s suppose that Python version 3.12.1 is the latest released 
version, and let’s also suppose that you would like to use that version to start 
working on a project. To first get the right Python interpreter ready, you should
install `micromamba`. Please refer to the `micromamba` 
documentation 
[here](https://mamba.readthedocs.io/en/latest/installation/micromamba-installation.html#automatic-install)^[https://mamba.readthedocs.io/en/latest/installation/micromamba-installation.html#automatic-install]
but on Linux, macOS and Git Bash on Windows (there’s also instructions for Powershell, if you don’t
have Git Bash installed on Windows), it should be as easy as:

```bash
"${SHELL}" <(curl -L micro.mamba.pm/install.sh)
```

for Poweshell use instead `Invoke-Expression ((Invoke-WebRequest -Uri https://micro.mamba.pm/install.ps1).Content)`

We can now use `micromamba` to create an environment that will contain a Python
interpreter and `pipenv`. Type the following command to create this environment:

```bash
micromamba create -n 3.12.1 pipenv python=3.12.1
```

This will create an environment named "3.12.1" that includes Python 3.12.1 and `pipenv`.

We can now use `pipenv` to install the packages for our project. But why don’t
we just the more common `pip` instead of `pipenv`, or even `micromamba` which
can also install any other Python package that we require for our projects? 
Why introduce yet another tool? In my opinion, `pipenv` has one absolutely crucial feature for reproducibility:
`pipenv` enables deterministic builds, which means that when using `pipenv`, we
will *always* get exactly the same packages installed.

"But isn’t that exctaly what using `requirements.txt` file does?" you wonder.
You are not entirely wrong. After all, if you make the effort to specify the
packages you need, and their versions, wouldn’t running `pip install -r
requirements.txt` also install exactly the same packages?

Well, not quite. Imagine for example that you need a package called `hello`
and you put it into your `requirements.txt` like so:

```bash
hello==1.0.1
```

Suppose that `hello` depends on another package called `ciao`. If you run `pip
install -r requirements.txt` today, you’ll get `hello` at version `1.0.1` and
`ciao`, say, at version `0.3.2`. But if you run `pip install -r
requirements.txt` in 6 months, you would still get `hello` at version `1.0.1`
but you might get a newer version of `ciao`. This is because `ciao` itself is
not specified in the `requirements.txt`, unless you made sure to add it (and
then also add its dependencies, and their dependencies...). `pipenv` takes care
of this for you by generating a so-called lock file automatically, 
and adds further security checks by comparing sha256 hashes
from the lock file to the ones from the downloaded packages, making sure that
you are actually installing what you believe you are. 

What about using `micromamba`? `micromamba` could indeed be used to install
the project’s dependencies, but would required another tool called `conda-lock`
to generate lock files, and in my experience, using `conda-lock` doesn’t always
work. I have 0 issues with `pipenv` on the other hand.

Now that `pipenv` is installed, let’s start using it to install the packages we
need for our project. Because the Python interpreter was installed using
`micromamba`, we either need to activate the environment to get access to it, or
we should use `micromamba run` to run the Python intpreter from this environment:

```bash
micromamba run -n 3.12.1 pipenv install polars==1.1.0 plotnine beautifulsoup4 pandas plotnine skimpy
```

(Little sidenote: in Chapter 2, we will be working together on a project using
real data with `polars` instead of `pandas`. But for now, let’s get `pandas`
installed: I’ll do a short comparison of the two, and then we’ll keep on using
`polars` for the remainder of the book.)

As you can see, I chose to install specific versions of packages. This is
because I want you to follow along with the same versions as in the book. You
could remove the `==x.y.z` strings from the command above to install the latest
versions of the packages available if you prefer, but then there would be no
guarantee that you would find the same results as I do in the remainder of the
book.

You should see now two new files in the `housing` folder, `Pipfile` and
`Pipfile.lock`. Start by opening `Pipfile`, it should look like this:

```
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
beautifulsoup4 = "==4.12.2"
pandas = "==2.1.4"
plotnine = "==0.12.4"
skimpy = "==0.0.11"

[dev-packages]

[requires]
python_version = "3.10"
python_full_version = "3.10.5"
```

I think that this file is pretty self-evident: the packages being used for this
project are listed alongside their versions. The exact Python version is also
listed. Sometimes, depending on how you set up the project, it could happen that
the Python version listed is not the same, or that only the field
`python_verison=` is listed. In this case, I highly recommend you change it to
match the same version as in the `.python-version` file that was generated by
`pyenv`, and add the `python_full_version=` field if necessary, in order to
avoid any possible differences in how the code runs. If you edited the `Pipfile`
then you need to run `pipenv lock` to regenerate the `Pipfile.lock` file as well:

```bash
pipenv lock
```

this will make sure to also set the required/correct Python version in there.

If you open the `Pipfile.lock` in a text editor, you will see that it is a json
file and that is also lists the dependecies of your project, but also the
dependencies’ dependencies. You will also notice several fields called `hashes`.
These are there for security reasons: whenever someone, (or you in the future)
will regenerate this environment, the packages will get downloaded and their
hashes will get compared to the ones listed in the `Pipfile.lock`. If they don’t
match, then something very wrong is happening and packages won’t get installed.

To check whether everything installed correctly, drop into the development shell using:

```bash
pipenv shell
```

and start the Python interpreter:

```bash
python
```

Then check that the correct versions of the packages were installed:

```{python, eval=F, python.reticulate=F}
import pandas as pd
pd.__version__
```

You should see `2.1.4` as the listed version.

## Debugging

It can sometimes happen that `pipenv` does not use the right version of Python.
Running `pipenv shell` and then starting the Python interpreter will start a
different version of Python than the one you expect/need.

In that case, it might be best to simply start over. Start by completely
removing the virtual environment and packages by running:

```bash
pipenv --rm
```

Make sure that the correct version of Python (or rather, the version you need)
is specified in the `Pipfile`. For example, in my case:

```
[requires]
python_full_version = "3.10.5"
```

(you might instead see `python_version = "3.10"`, or any other version, in that
case I recommend you specify `python_full_version` as I did above, check the
`.python-version` file that was generated by `pyenv` if you don’t remember the
right version).

Now, restore the environment and packages by running:

```bash
pipenv install
```

`pipenv install` will regenerate the `Pipfile.lock` file to list the required Python
version, and then install the packages. It essentially runs `pipenv lock` to generate
the lock file, and then `pipenv sync` to install the packages from the lock file.

Check if `pipenv` now uses the correct Python version.

```bash
pipenv run python --version
```

## A high-level description of how to set up a project

Ok, so to summarise, we install `pyenv` which will make it easy to install any
version of Python that we require, and then we installed `pipenv`, which we use
to install packages. The advantage of using `pipenv` is that we get
deterministic builds, and `pipenv` works well with `pyenv` to build
project-specific environments.

The way I would suggest you use these tools now, is that for each project, you
install the latest available version of Python, define it as the local version
using `pyenv local`, and then install packages by specyifing their versions,
like so:

```bash
pipenv --python 3.10.5 install beautifulsoup4==4.12.2 pandas==2.1.4 plotnine==0.12.4 skimpy==0.0.11
```

(Replace the versions of Python and packages by the latest, or those you need.)

This will ensure that your project uses the correct software stack, and that collaborators
or future you will be able to regenerate this environment by calling `pipenv sync`.
`pipenv sync` differs from `pipenv install` because it will not touch the `Pipfile.lock`
file, and will just download the packages as listed in the lock file. This is also
the command that we will use later, in the chapter on CI/CD.
